{"version":3,"sources":["../src/math/math.ts","../src/eddsa/client.ts","../src/wasm/client.ts","../src/utils/uuid.ts","../src/utils/hex.ts"],"names":["add","a","b","subtract","EddsaClient","wasmApi","storageProvider","clientKeyShare","payload","wasmReadyPayload","num1","num2","fetchWasmBuffer","getWasmBuffer","generateUUID","c","hexToU8a","hex","arrayLength","uint8Array","i","byte","u8aToHex","acc"],"mappings":"AAOO,SAASA,EAAIC,EAAWC,EAAW,CACzC,OAAOD,EAAIC,CACZ,CASO,SAASC,EAASF,EAAWC,EAAW,CAC9C,OAAOD,EAAIC,CACZ,CClBA,IAAME,EAAN,KAAkB,CAChB,QACA,gBACA,eAAgC,KAEhC,YAAYC,EAAkBC,EAAqC,CACjE,KAAK,QAAUD,EACf,KAAK,gBAAkBC,CACzB,CAEA,MAAM,YAAa,CAEjB,IAAMC,EAAiB,MAAM,KAAK,gBAAgB,IAAI,YAAY,EAElE,OAAKA,GAOL,KAAK,eAAiBA,EAEf,wBARE,mBASX,CAEA,MAAM,KAAKC,EAAkC,CAC3C,GAAI,CAAC,KAAK,eACR,MAAM,IAAI,MAAM,yBAAyB,EAE3C,IAAMC,EAAmB,KAAK,mBAAmBD,CAAO,EAOxD,OALkB,MAAM,KAAK,QAAQ,YACnC,KAAK,eACLC,CACF,CAGF,CAEA,mBAAmBD,EAAkC,CAEnD,OAAO,KAAK,UAAUA,CAAO,CAC/B,CAEA,MAAM,eAAgB,CAAC,CAGvB,IAAIE,EAAcC,EAAc,CAC9B,OAAO,KAAK,QAAQ,IAAID,EAAMC,CAAI,CACpC,CACF,ECrDA,IAAMC,EAAkB,SACtB,WAAW,KAAK,CACd,EAAM,GAAM,IAAM,IAAM,EAAM,EAAM,EAAM,EAAM,EAAM,IAAM,IAAM,IAClE,IAAM,EAAM,EAAM,GAAM,EAAM,IAAM,IAAM,EAAM,IAAM,EAAM,IAAM,IAClE,IAAM,IAAM,EAAM,EAAM,EAAM,EAAM,IAAM,IAAM,IAAM,IAAM,EAAM,EAClE,EAAM,GAAM,IAAM,IAAM,EAAM,EAAM,GAAM,IAAM,IAAM,IAAM,IAAM,EAClE,EAAM,IAAM,IAAM,IAAM,IAAM,EAAM,EAAM,GAAM,EAAM,GAAM,EAAM,IAClE,EACF,CAAC,EAEUC,EAAgB,SACR,MAAMD,EAAgB,ECXpC,SAASE,GAAe,CAC7B,MAAO,uCAAuC,QAAQ,QAAS,SAAUC,EAAG,CAC1E,IAAI,EAAK,KAAK,OAAO,EAAI,GAAM,EAE/B,OADMA,GAAK,IAAM,EAAK,EAAI,EAAO,GACxB,SAAS,EAAE,CACtB,CAAC,CACH,CCNO,IAAMC,EAAYC,GAAgB,CACvC,GAAIA,EAAI,OAAS,IAAM,EACrB,MAAM,IAAI,MAAM,oBAAoB,EAEtC,IAAMC,EAAcD,EAAI,OAAS,EAC3BE,EAAa,IAAI,WAAWD,CAAW,EAC7C,QAASE,EAAI,EAAGA,EAAIF,EAAaE,IAAK,CACpC,IAAMC,EAAO,OAAO,SAASJ,EAAI,MAAMG,EAAI,EAAGA,EAAI,EAAI,CAAC,EAAG,EAAE,EAC5DD,EAAWC,CAAC,EAAIC,CAClB,CACA,OAAOF,CACT,EAEaG,EAAYH,GAChBA,EAAW,OAChB,CAACI,EAAKF,IAASE,EAAMF,EAAK,SAAS,EAAE,EAAE,SAAS,EAAG,GAAG,EACtD,EACF","sourcesContent":["/**\n * Adds two numbers\n * @param a - The first input number\n * @param b - The second input number\n * @returns The sum of the two input numbers\n * @example add(1, 2) // 3\n */\nexport function add(a: number, b: number) {\n\treturn a + b;\n}\n\n/**\n * Subtracts two numbers\n * @param a - The first input number\n * @param b - The second input number\n * @returns The difference of the two input numbers\n * @example subtract(2, 1) // 1\n */\nexport function subtract(a: number, b: number) {\n\treturn a - b;\n}\n","import { StorageProviderApi, WasmApi } from \"~/eddsa/types\";\n\nclass EddsaClient {\n  wasmApi;\n  storageProvider;\n  clientKeyShare: string | null = null;\n\n  constructor(wasmApi: WasmApi, storageProvider: StorageProviderApi) {\n    this.wasmApi = wasmApi;\n    this.storageProvider = storageProvider;\n  }\n\n  async initialize() {\n    // Check if there is any client key already stored in the store provider\n    const clientKeyShare = await this.storageProvider.get(\"keyban-key\");\n\n    if (!clientKeyShare) {\n      return \"initialized-empty\";\n    }\n\n    // Feed the client share to the wasmApi (?)\n    // this.wasmApi.init(clientKeyShare)\n    // for now save it in the state\n    this.clientKeyShare = clientKeyShare;\n\n    return \"initialized-with-key\";\n  }\n\n  async sign(payload: Record<string, unknown>) {\n    if (!this.clientKeyShare) {\n      throw new Error(\"cannot sign without key\");\n    }\n    const wasmReadyPayload = this.prepareWasmPayload(payload);\n\n    const signature = await this.wasmApi.signMessage(\n      this.clientKeyShare,\n      wasmReadyPayload\n    );\n\n    return signature;\n  }\n\n  prepareWasmPayload(payload: Record<string, unknown>) {\n    // Not sure how the payload should be prepared\n    return JSON.stringify(payload);\n  }\n\n  async createKeypair() {}\n\n  // TESTING ONLY\n  add(num1: number, num2: number) {\n    return this.wasmApi.add(num1, num2);\n  }\n}\n\nexport { StorageProviderApi, WasmApi, EddsaClient };\n","const fetchWasmBuffer = async () =>\n  Uint8Array.from([\n    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x87, 0x80, 0x80,\n    0x80, 0x00, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f, 0x03, 0x82, 0x80,\n    0x80, 0x80, 0x00, 0x01, 0x00, 0x07, 0x87, 0x80, 0x80, 0x80, 0x00, 0x01,\n    0x03, 0x61, 0x64, 0x64, 0x00, 0x00, 0x0a, 0x8d, 0x80, 0x80, 0x80, 0x00,\n    0x01, 0x87, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a,\n    0x0b,\n  ]);\n\nexport const getWasmBuffer = async (): Promise<ArrayBuffer> => {\n  const wasmBuffer = await fetchWasmBuffer();\n  // any work on wasm before we serve it further\n  return wasmBuffer;\n};\n","export function generateUUID() {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    let r = (Math.random() * 16) | 0,\n      v = c == \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n","export const hexToU8a = (hex: string) => {\n  if (hex.length % 2 !== 0) {\n    throw new Error(\"Invalid hex string\");\n  }\n  const arrayLength = hex.length / 2;\n  const uint8Array = new Uint8Array(arrayLength);\n  for (let i = 0; i < arrayLength; i++) {\n    const byte = Number.parseInt(hex.slice(i * 2, i * 2 + 2), 16);\n    uint8Array[i] = byte;\n  }\n  return uint8Array;\n};\n\nexport const u8aToHex = (uint8Array: Uint8Array) => {\n  return uint8Array.reduce(\n    (acc, byte) => acc + byte.toString(16).padStart(2, \"0\"),\n    \"\"\n  );\n};\n"]}
